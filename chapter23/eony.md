# 테이블 파티셔닝
## 테이블 파티셔닝이란?
- 하나의 테이블을 물리적으로 여러 테이블로 분할하여 데이터를 저장하는 기법
    - 인덱스도 함께 물리적으로 분리됨
- 사용자는 하나의 테이블로 인식해 사용 가능
- 테이블의 특정 컬럼 / 계산식을 기준으로 날짜/숫자 범위나 리스트, 해시 형태 등으로 분할 가능

## 테이블 파티셔닝이 필요한 이유
- 삭제 가능한 이력 데이터들을 효율적으로 관리 가능함
    - 로그성 데이터들 (보관 기간을 기준으로 파티셔닝 가능)
    - 보관 기간에 따라 일정 기간 지난 데이터를 제거하는 경우, 데이터 삭제가 아닌 파티션 드랍으로 처리 가능
        - 명령문 하나로 손쉽게 처리 가능
        - 사용된 디스크 공간 온전히 반환 가능
- 자원 사용 효율 증가 및 쿼리 성능 향상
    - 최근에 저장된 데이터들 위주로 조회하는 경우 (EX. 게시판)
        - 날짜 범위로 파티셔닝
        - 쿼리가 특정 날짜 범위의 데이터를 요청하면 조건 범위에 해당하지 않는 파티션은 쿼리 처리에서 제외됨
            - A.K.A 파티션 프루닝(`Partition Pruning`)

## 파티셔닝 타입
```sql
CREATE TABLE table_name (
    ...
# 지정된 범위값을 바탕으로 파티션. 날짜와 숫자 값 기반
) PARTITION BY [RANGE|RANGE_COLUMNS] (...)
# 파티션 키에 대한 해싱값으로 분할(파티션 키에 표현식 직접 지정 가능)
) PARTITION BY [HASH|LINEAR_HASH] (...)
# 지정된 값 목록을 기준으로 분할
) PARTITION BY [LIST|LIST_COLUMNS] (...)
# 파티션 키에 대한 해싱값으로 분할(파티션 키에 컬럼만 사용할 수 있음)
) PARTITION BY [KEY|LINEAR_KEY] (...)
```
- 일정 범위로 파티션을 분할해서 사용하는 경우가 대다수
- 제일 많이 사용하는 타입은 RANGE & RANGE_COLUMNS

## 파티션 테이블 사용 제약 및 주의사항
- 외래키 및 공간 데이터 타입(GEOMETRY 등), 전문검색 인덱스 사용 불가
    - 반대로 말해, 해당 조건에 해당하는 테이블은 파티셔닝 불가
- 파티션 표현식에 MySQL 내장 함수를 사용할 수는 있으나 이들 모두가 파티션 프루닝 기능을 지원하는 것인 아님
    - `TO_DAYS()`, `TO_SECONDS()`, `YEAR()`, `UNIX_TIMESTAMP()`만 지원
- 테이블의 모든 고유키(PK, UK)에 파티셔닝 기준 컬럼이 반드시 포함되어야함
    - 일반 테이블에선 전체 테이블을 기준으로 인덱스가 생성되는 글로벌 인덱스로 설정되지만, 파티셔닝이 적용되면 파티셔닝된 각 테이블을 기준으로 인덱스가 관리되는 로컬 인덱스 구조로 돌아감
    - 파티셔닝된 각 테이블 사이의 유니크성을 보장하기 위한 장치
- WHERE 절에 파티셔닝 기준 컬럼에 대한 조건이 포함되어야 파티션 프루닝이 적용됨
    - 그렇지 않으면 전체 파티션을 탐색하게됨
- 값이 자주 변경되는 컬럼을 파티션 기준 컬럼으로 설정하면 안됨
    - 파티션 기준컬럼 변경 시 파티션 간 데이터 이동이 발생하기 때문

## 파티션 테이블 사용 예시
1. RANGE
    - 파티션 표현식에 컬럼 또는 계산식 허용
    - 컬럼 지정 시 하나의 컬럼만 사용 가능
    - 계산식 또는 컬럼 모두 정수형 값만 허용
2. RANGE_COLUMNS
    - 파티션 표현식에 컬럼만 허용
    - 하나 이상의 컬럼 사용 가능
    - 정수형, 문자열, 날짜타입 값도 허용됨
        - 지원하지 않는 타입도 물론 있어서 확인 후 사용 필요함

### 파티션 추가
- 마지막 파티션 이후 범위의 신규 파티션을 추가
    - `MAXVALUE` 파티션이 존재하지 않는 경우
        - `ALTER TABLE user_log ADD PARTITION (PARTITION p202404 VALUES LESS THAN ('2024-05-01'));`
    - `MAXVALUE` 파티션이 존재하는 경우
        - `ALTER TABLE user_log REORGANIZE PARTITION pMAX INTO (...)`
- 기존 파티션들 사이에 새로운 파티션 추가
    - ADD PARTITION 명령 사용 불가. REORGANIZE PARTITION 명령으로 작업 필요함

### 파티션 제거
- DROP PARTITION
    - 필요 시 별도 스토리지 백업 후 제거
    
### 파티션 비우기
- TRUNCATE PARTITION

### 짚고 넘어가면 좋은 것
- 주로 접근하는 범위 또는 삭제 대상 범위를 바탕으로 일/주/월/년 등으로 필요에 맞게 파티셔닝
    - 파티션이 지나치게 작거나 크면 성능에 악영향을 미치므로 요구사항에 맞게 적절히 설정하는 것이 중요
- 예상치 못한 상황을 대비해 MAXVALUE 파티션 사용
    - 저장 대상 파티션이 존재하지 않으면 에러 발생하여 데이터가 저장되지 않기 때문
    - 에러 방지 차원에서 MAXVALUE는 꼭 사용하기
- 파티션 추가/삭제 시 메타데이터 락이 발생함. 가능하다면 트래픽 적은 시점에 수행
- 필요 시 파티션을 관리할 수 있는 자동화 스크립트 개발

## 파티션 테이블과 인덱스 사용
- 고유키가 아닌 일반 인덱스는 자유롭게 구성해 사용 가능
- 파티션 별로 동일한 구조의 인덱스가 생성됨
- 파티션 프루닝 이후 추려진 파티션들에서 인덱스 스캔
- 쿼리 실행계획 확인 가능
    - 실행 계획의 `partitions` 항목에서 접근 대상 파티션 목록 확인 가능
    - 쿼리의 FROM 절에 특정 파티션만 조회하도록 지정 가능함
        - `SELECT ... FROM tbl PARTITION (p202404)`
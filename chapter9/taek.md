# 에러 핸들링

## 1. MySQL 에러 구분
### 1) Global Error
- MySQL 서버 & 클라이언트(드라이버, 커넥터 등)에서 모두 발생
### 2) Server Error
- MySQL 서버에서 발생
- 일부 서버 에러는 클라이언트로 전달되므로 클라이언트에 노출된다 하더라도 서버 에러일 수 있다
### 3) Client Error
- 클라이언트에서 발생

## 2. MySQL 에러 포맷
```bash
ERROR 1062 (23000): Duplicate entry 'abc...' for key 'ux_email'
# 1062 -> Error No
# 23000 -> SQL State
# Duplicated ... -> Error Message
```

### 1) Error No
- 4자리 정수
- MySQL에서만 유효한 정보
- 에러 번호의 구분
  - 1~999: 글로벌 에러
  - 1000~1999: 서버 에러
  - 2000~2999: 클라이언트 에러
  - 3000~: 서버 에러
  - MY-010000~: 서버 에러
- MySQL 8.0 이후 3500 이후 대역과 MY-010000 대역이 추가됨
- MySQL의 스토리지 엔진(NDB, InnoDB 등)에 종속적인 경우가 많으므로 에러 번호를 사용한 에러 처리는 적절치 않다

### 2) SQL State
- 5글자 영문 숫자로 구성
- ANSI에서 제정 (벤더사에 의존 X)
- SQL_STATE는 앞 2글자와 뒷 3글자 2개의 파트로 분류한다
  - 앞 2글자) 상태값의 분류
    - 00: 정상
    - 01: 경고
    - 02: 레코드 없음
    - HY: ANSI에서 표준 분류 X, (벤더사에 의존 O)
    - 나머지는 모두 에러
  - 뒷 3글자) 주로 숫자값이며, 각 분류별 상세 에러코드 값
- **SQL State를 가지고 에러를 핸들링해야 한다** 
  - ANSI 표준을 따르므로, 동일 에러는 동일 SQL State를 가진다
  - My 스토리지 엔진간의 호환성 및 벤더 DBMS와의 호환성을 제공한다
- **물론 100% 호환은 아니고, SQL State가 "HY"인 경우에는 미분류 상태이므로 Error No를 이용한 에러 처리가 권장된다**

### 3) Error Message
- 사람이 인식할 수 있는 문자열
- 버전 간 호환이 잘 되지 않고, 변경사항도 릴리즈 노트에 명시되지 않는 편
- 응용 프로그램에서 에러를 핸들링하기 위해 사용하면 안 된다


## 4. Best Practice
- DBA와의 소통 시 SQL 문장과 온전한 Error 정보를 전달한다
- DBMS의 서버 에러를 버리는 방식 대신, 애플리케이션 내의 Exception에 SQL Exception을 온전히 래핑하여 유지한다
- ORM 사용 시 ORM에서 SQL 에러를 생성하는 경우가 있으므로 DBMS 에러와 애플리케이션 에러를 구분한다
- DBMS 에러는 반드시 로깅한다

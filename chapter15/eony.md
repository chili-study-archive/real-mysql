# 풀스캔 쿼리 패턴 및 튜닝
(1) 컬럼이 가공되는 경우 (컬럼이 연산의 대상으로 포함되는 경우)
- 연산
    - `SELECT ... WHERE count + 10 < 2000`
        - count 컬럼에 대해 연산이 발생
- 함수
    - `SELECT ... WHERE MOD(id, 2) = 0`
        - id 컬럼에 MOD 함수 실행됨
- 형변환
    - `SELECT ... WHERE str_column=12345`
        - 문자 str_column이 숫자로 형변환됨
        - 주의
            - 형변환 우선순위가 있어서 항상 적용되는 것은 아님
            - `SELECT ... WHERE int_column='12345'`에서는 인덱스 사용 가능함
            - 물론 형변환 자체에 민감하게 대처해야함

인덱스가 컬럼의 원본값을 기반으로 생성되어있고, 가공된 컬럼 값은 인덱싱되어있지 않으므로 컬럼에 인덱스가 존재해도 사용이 불가함

(2) 인덱싱 되지 않은 컬럼을 조건절에 OR 연산과 함께 사용하는 경우
- `SELECT ... WHERE {인덱싱된 컬럼} = ? OR {인덱싱되지 않은 컬럼} = ?`
    - 각 개별 조건을 만족하는지 모두 확인해야하므로 풀스캔 발생함
- 만약 AND 연산이라면 인덱싱된 컬럼으로 먼저 filter를 한 후 다음 연산을 수행하므로 OR에서보단 부담이 덜함

(3) 복합 인덱스의 컬럼들 중 선행 컬럼을 조건에서 누락
- 구성된 복합 인덱스 컬럼 순서로 정렬된 인덱스를 저장하므로, 선행 컬럼 조건이 누락되면 인덱스를 사용할 수 없음

(4) LIKE 연산에서 시작 문자열을 와일드 카드로 사용
- `LIKE '%search%'`
    - 인덱스 사용 시 문자열은 prefix 비교만 가능함.

(5) REGEXP 연산 사용
- 정규표현식 확인 작업으로 인해 인덱스 사용이 불가함

(6) 테이블 풀스캔이 인덱스 사용보다 더 효율적인 경우
- 결과적으로 모든 데이터를 스캔한다고 했을 땐 인덱스를 통한 스캔보다 그냥 테이블 풀스캔하는게 더 빠름
- 옵티마이저가 쿼리 실행 전 데이터 개수를 비롯한 여러 요소들을 판단하여 인덱스를 사용할 수 있는 상황에서도 풀스캔을 하는 경우가 존재함

(번외) NOT Equal 조건과 IS NOT NULL 조건
- 두 케이스 모두 EQUAL / IS 조건과 동일하게 인덱스를 사용함. 사용하지 않는다는 것은 잘못된 정보